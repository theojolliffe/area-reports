// Generated by CoffeeScript 1.7.1

/**
 * Natural Language base class
 * ------------------------------------------------------------
 * @name NaturalLanguage
 * 
 * @constructor
 * @param {Array} data - a list of inputs
 */

(function() {
  var NaturalLanguage;

  exports.NaturalLanguage = NaturalLanguage = (function() {

    /**
     * ------------------------------------------------------------
     * Prepare resource
     * ------------------------------------------------------------
     */
    var addSimpleSentence, buildCompoundSentence, buildSentences, buildSimpleSentence, calculateLevel, calculatePriority, calculateType, capitalize, config, getCompoundSentenceList, getDifference, getDisplayInfo, getSimpleSentenceList, global, groupData, replaceCombinedStr, replaceStr, selectData, sentences, setAttrs, _;

    global = null;

    _ = require('underscore');

    config = require('./../resources/config.json');

    sentences = require('./../resources/sentences.json');

    function NaturalLanguage(data) {
      this.data = data;
      this.dataConfig = {};
      this.sentenceConfig = {};
      global = this;
    }


    /**
     * ------------------------------------------------------------
     * HELPER FUNCTION
     * ------------------------------------------------------------
     */


    /**
     * Change the first character of the string to capital
     * ------------------------------------------------------------
     * @name capitalize
     * @param  {string} data
     * @return {string} capitalized string
     */

    capitalize = function(data) {
      return data.charAt(0).toUpperCase() + data.slice(1);
    };


    /**
     * Replace sentence pattern with string in data object
     * (single sentence, no capitalization or full stop)
     * ------------------------------------------------------------
     * @name replaceStr
     * @param  {array}  patterns - array of sentences
     * @param  {object} data - displayInfo object
     * @return {string} final sentence
     */

    replaceStr = function(patterns, data) {
      var pattern;
      pattern = _.sample(patterns);
      _.each(data, function(item, key) {
        return pattern = pattern.replace("{" + key + "}", item);
      });
      return pattern;
    };


    /**
     * Replace sentence pattern with string in data object
     * (combined sentence, with capitalization and full stop)
     * ------------------------------------------------------------
     * @name replaceCombinedStr
     * @param  {array}  patterns - array of sentences
     * @param  {array}  data - array of displayInfo object
     * @return {string} final sentence
     */

    replaceCombinedStr = function(patterns, data) {
      var pattern;
      pattern = _.sample(patterns);
      _.each(data, function(items, i) {
        return _.each(items, function(item, key) {
          return pattern = pattern.replace("{" + key + "." + i + "}", items[key]);
        });
      });
      return pattern;
    };


    /**
     * ------------------------------------------------------------
     * METHOD LIST
     * ------------------------------------------------------------
     */


    /**
     * Add more required attributes
     * ------------------------------------------------------------
     * @name setAttrs
     * @param  {array}  data - array of inputs
     * @return {Object} new data with more attributes
     * @private
     */

    setAttrs = function(data) {
      _.each(data, function(item, i) {
        if (item.options !== void 0) {
          item.options = _.extend(config["default"], item.options);
        } else {
          item.options = config["default"];
        }
        if (!item.dataType) {
          item.dataType = 'default';
        }
        if (global.dataConfig[item.dataType] && global.dataConfig[item.dataType].setAttrs) {
          item = global.dataConfig[item.dataType].setAttrs(item);
        }
        if (typeof item.alwaysShow === 'undefined') {
          item.alwaysShow = false;
        }
        if (!item.contentGroup) {
          item.contentGroup = 'default';
        }
        if (!item.sentenceType) {
          item.sentenceType = 'default';
        }
        if (item.precision === 'undefined') {
          item.precision = 0;
        }
        item.difference = getDifference(item);
        item.displayInfo = getDisplayInfo(item);
        item.priority = calculatePriority(item);
        item.level = calculateLevel(item);
        return item.levelType = calculateType(item.level);
      });
      return data;
    };


    /**
     * Get the difference between old value and current value
     * ------------------------------------------------------------
     * @name getDifference
     * @param  {object}        data
     * @return {number/string} difference value or 'na' if there is no oldData
     * @private
     */

    getDifference = function(data) {
      if (global.dataConfig[data.dataType] && global.dataConfig[data.dataType].getDifference) {
        return global.dataConfig[data.dataType].getDifference(data);
      }
      if (typeof data.oldData !== 'undefined' && typeof data.oldData === 'number') {
        return data.newData - data.oldData;
      } else {
        return 'na';
      }
    };


    /**
     * Prepare strings required to show in the sentence
     * ------------------------------------------------------------
     * @name getDisplayInfo
     * @param  {object} data
     * @return {object} information required to display in the sentence
     * @private
     */

    getDisplayInfo = function(data) {
      var result;
      if (global.dataConfig[data.dataType] && global.dataConfig[data.dataType].getDisplayInfo) {
        return global.dataConfig[data.dataType].getDisplayInfo(data);
      }
      result = {};
      result.title = data.title.toLowerCase();
      if (typeof data.oldData !== 'undefined') {
        if (typeof data.oldData === 'number') {
          result.oldData = data.oldData.toFixed(data.precision);
        } else {
          result.oldData = data.oldData.toLowerCase();
        }
        if (typeof data.difference === 'number') {
          result.difference = Math.abs(data.difference).toFixed(data.precision);
        }
      }
      if (typeof data.newData === 'number') {
        result.newData = data.newData.toFixed(data.precision);
      } else {
        result.newData = data.newData.toLowerCase();
      }
      return result;
    };


    /**
     * Calculate the priority of change
     * ------------------------------------------------------------
     * @name calculatePriority
     * @param  {object} data
     * @return {number} new priority
     * @private
     */

    calculatePriority = function(data) {
      var newPriority, priorityConfig;
      if (global.dataConfig[data.dataType] && global.dataConfig[data.dataType].calculatePriority) {
        if (typeof data.priority !== 'undefined') {
          data.options.priority.init = data.priority;
        }
        return global.dataConfig[data.dataType].calculatePriority(data.difference, data.options.priority);
      }
      priorityConfig = data.options.priority;
      if (data.difference === 'na') {
        return priorityConfig.init;
      } else if (data.difference > 0) {
        newPriority = priorityConfig.init + (priorityConfig.positiveFactor * data.difference);
      } else {
        newPriority = priorityConfig.init + (priorityConfig.negativeFactor * Math.abs(data.difference));
      }
      return parseInt(newPriority.toFixed(0), 10);
    };


    /**
     * Calculate the intesity of change
     * ------------------------------------------------------------
     * @name calculateLevel
     * @param  {object} data
     * @return {number} intensity of the change
     * @private
     */

    calculateLevel = function(data) {
      var absoluteDifference, level, levelConfig;
      if (global.dataConfig[data.dataType] && global.dataConfig[data.dataType].calculateLevel) {
        return global.dataConfig[data.dataType].calculateLevel(data.difference, data.options.level);
      }
      levelConfig = data.options.level;
      if (data.difference === 'na') {
        level = 'na';
      } else {
        absoluteDifference = Math.abs(data.difference);
        if (absoluteDifference < levelConfig.threshold) {
          level = 0;
        } else {
          level = Math.ceil(data.difference / levelConfig.sensitiveness);
          if (level > 3) {
            level = 3;
          }
          if (level < -3) {
            level = -3;
          }
        }
      }
      return level;
    };


    /**
     * Calculate the type of intesity
     * ------------------------------------------------------------
     * @name calculateType
     * @param  {number} level
     * @return {string} levelType
     * @private
     */

    calculateType = function(level) {
      if (level > 0) {
        return 'positive';
      } else if (level < 0) {
        return 'negative';
      } else if (level === 'na') {
        return 'na';
      } else {
        return 'neutral';
      }
    };


    /**
     * Select number of data to display and sort by priority
     * ------------------------------------------------------------
     * @name selectData
     * @param  {array}  data - array of data split into two groups: alwaysShow and sortedData
     * @param  {number} nData - number of data to show
     * @return {array}  selected, sorted data by priority
     * @private
     */

    selectData = function(data, nData) {
      var groupedData, nRemaining, result;
      groupedData = groupData(data);
      result = groupedData.alwaysShow;
      if (nData === -1) {
        return result.concat(groupedData.sortedData);
      }
      if (result.length < nData) {
        nRemaining = nData - result.length;
        result = result.concat(groupedData.sortedData.slice(0, nRemaining));
      }
      result.sort(function(a, b) {
        return b.priority - a.priority;
      });
      return result;
    };


    /**
     * Group data by alwaysShow attr and sort the group by priority
     * ------------------------------------------------------------
     * @name groupData
     * @param  {array} data - array of data
     * @return {array} data split into two groups, alwaysShow and sortedData
     * @private
     */

    groupData = function(data) {
      data = _.filter(data, function(item) {
        return !item.hidden;
      });
      data = _.groupBy(data, 'alwaysShow');
      data.sortedData = [];
      data.alwaysShow = [];
      if (data[false]) {
        data[false].sort(function(a, b) {
          return b.priority - a.priority;
        });
        data.sortedData = data[false];
      }
      if (data[true]) {
        data.alwaysShow = data[true];
      }
      return data;
    };


    /**
     * Get a valid list of sentences for random selecting
     * ------------------------------------------------------------
     * @name getSimpleSentenceList
     * @param  {object} data - data object
     * @param  {array}  simpleSentences - sentences from all types
     * @return {array}  array of valid sentences
     * @private
     */

    getSimpleSentenceList = function(data, simpleSentencese) {
      if (global.sentenceConfig[data.sentenceType] && global.sentenceConfig[data.sentenceType].getSimpleSentenceList) {
        return global.sentenceConfig[data.sentenceType].getSimpleSentenceList(data, simpleSentencese);
      }
      if (typeof data.oldData === 'undefined') {
        if (typeof sentences.simpleSentences[data.sentenceType] !== 'undefined' && typeof sentences.simpleSentences[data.sentenceType]['na'] !== 'undefined') {
          return sentences.simpleSentences[data.sentenceType]['na'];
        } else {
          return sentences.simpleSentences['default']['na'];
        }
      } else {
        if (typeof sentences.simpleSentences[data.sentenceType] !== 'undefined' && typeof sentences.simpleSentences[data.sentenceType][data.levelType] !== 'undefined') {
          if (typeof sentences.simpleSentences[data.sentenceType][data.levelType][data.level.toString()] !== 'undefined') {
            return sentences.simpleSentences[data.sentenceType][data.levelType][data.level.toString()];
          } else {
            return sentences.simpleSentences[data.sentenceType][data.levelType];
          }
        } else {
          return sentences.simpleSentences['default'][data.levelType][data.level.toString()];
        }
      }
    };


    /**
     * Group data into contentGroups and loop through each
     * contentGroup to create sentence(s)
     * ------------------------------------------------------------
     * @name buildSimpleSentence
     * @param  {object} data - data object
     * @return {array}  array of sentences
     * @private
     */

    buildSimpleSentence = function(data) {
      var simpleSentences;
      simpleSentences = getSimpleSentenceList(data, sentences.simpleSentences);
      return replaceStr(simpleSentences, data.displayInfo);
    };


    /**
     * Add simple sentence into the data object
     * ------------------------------------------------------------
     * @name addSimpleSentence
     * @param  {array} array of data to generate simple sentences
     * @return {array} array of data with sentence attribute inserted
     * @private
     */

    addSimpleSentence = function(data) {
      var i;
      for (i in data) {
        data[i].displayInfo.sentence = buildSimpleSentence(data[i]);
      }
      return data;
    };


    /**
    * Get a valid list of compound sentences
    * ------------------------------------------------------------
    * @name getCompoundSentenceList
    * @param  {object} data - data object
    * @param  {array}  compoundSentences - sentences from all types
    * @return {array}  array of valid sentences
    * @private
     */

    getCompoundSentenceList = function(data, compoundSentences) {
      if (global.sentenceConfig[data.sentenceType] && global.sentenceConfig[data.sentenceType].getCompoundSentenceList) {
        return global.sentenceConfig[data.sentenceType].getCompoundSentenceList(data, compoundSentences);
      }
      if (sentences.compoundSentences[data.sentenceType] !== void 0) {
        return compoundSentences[data[0].sentenceType];
      } else {
        return compoundSentences["default"];
      }
    };


    /**
     * Combine two simple sentencese that are in the same sentenceGroup
     * ------------------------------------------------------------
     * @name buildCompoundSentence
     * @param  {array}  array of one or two data objects to combine
     * @return {string} a combine sentence
     * @private
     */

    buildCompoundSentence = function(data) {
      var compoundSentences, moreDisplayInfo, selectedSentences, type, types;
      types = _.pluck(data, 'levelType');
      type = types.join('_');
      moreDisplayInfo = _.pluck(addSimpleSentence(data), 'displayInfo');
      compoundSentences = getCompoundSentenceList(data, sentences.compoundSentences);
      selectedSentences = _.find(compoundSentences, function(group) {
        return _.contains(group.type, type);
      });
      return capitalize(replaceCombinedStr(selectedSentences.sentences, moreDisplayInfo));
    };


    /**
     * Group data into contentGroups and loop through each
     * contentGroup to create sentence(s)
     * ------------------------------------------------------------
     * @name buildSentences
     * @param  {array} data - array sorted by priority but not grouped
     * @return {array} array of sentences
     * @private
     */

    buildSentences = function(data) {
      var result;
      result = [];
      data = _.groupBy(data, 'contentGroup');
      _.each(data, function(group) {
        var i, _results;
        if (group.length > 2) {
          i = 0;
          _results = [];
          while (i < group.length) {
            if (i + 1 === group.length) {
              result.push(buildCompoundSentence([group[i]]));
            } else {
              result.push(buildCompoundSentence([group[i], group[parseInt(i) + 1]]));
            }
            _results.push(i = i + 2);
          }
          return _results;
        } else {
          return result.push(buildCompoundSentence(group));
        }
      });
      return result;
    };

    NaturalLanguage.prototype.addType = function(title, func) {
      if (func == null) {
        func = {};
      }
      if (this.dataConfig[title]) {
        return this.dataConfig[title] = _.extend(this.dataConfig[title], func);
      } else {
        return this.dataConfig[title] = func;
      }
    };

    NaturalLanguage.prototype.addSentence = function(title, func) {
      if (func == null) {
        func = null;
      }
      if (this.sentenceConfig[title]) {
        return this.sentenceConfig[title] = _.extend(this.sentenceConfig[title], func);
      } else {
        return this.sentenceConfig[title] = func;
      }
    };


    /**
     * Generate sentences from a list of data
     * ------------------------------------------------------------
     * @name NaturalLanguage.generate
     * @param {number} nData - number of sentences to generate
     * @return {String/Number/Object/Function/Boolean} desc
     * @public
     */

    NaturalLanguage.prototype.generate = function(nData) {
      var data, result;
      if (nData == null) {
        nData = -1;
      }
      data = setAttrs(this.data);
      data = selectData(data, nData);
      result = buildSentences(data);
      return result.join(' ');
    };

    return NaturalLanguage;

  })();

}).call(this);
